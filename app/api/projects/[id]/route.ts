import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { getSession } from "@/lib/auth";

export async function GET(
  _req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const user = await getSession();
  if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  const { id } = await params;
  const project = await prisma.project.findFirst({
    where: { id, userId: user.id },
    include: {
      regulatoryAnalysis: true,
      sitePlanData: true,
      feasibilityReport: true,
      documents: true,
    },
  });
  if (!project) return NextResponse.json({ error: "Not found" }, { status: 404 });
  return NextResponse.json({ project });
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const user = await getSession();
  if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  const { id } = await params;
  const project = await prisma.project.findFirst({ where: { id, userId: user.id } });
  if (!project) return NextResponse.json({ error: "Not found" }, { status: 404 });
  const body = await request.json();
  const data: Record<string, unknown> = {
    name: body.name,
    description: body.description,
    address: body.address,
    municipality: body.municipality,
    parcelIds: Array.isArray(body.parcelIds) ? body.parcelIds.join(",") : body.parcelIds,
    parcelArea: body.parcelArea,
    northAngle: body.northAngle != null ? Number(body.northAngle) : undefined,
    status: body.status,
    scale: body.scale,
  };
  if (body.parcelGeometry !== undefined) {
    data.parcelGeometry = typeof body.parcelGeometry === "string" ? body.parcelGeometry : (body.parcelGeometry != null ? JSON.stringify(body.parcelGeometry) : null);
  }
  const updated = await prisma.project.update({
    where: { id },
    data,
  });
  // Auto location plan: ensure LOCATION_PLAN document when address + parcels
  const hasAddress = !!updated.address?.trim();
  const hasParcels = !!(updated.parcelIds?.trim() || updated.coordinates);
  if (hasAddress && hasParcels) {
    const existing = await prisma.document.findFirst({
      where: { projectId: id, type: "LOCATION_PLAN" },
    });
    if (!existing) {
      await prisma.document.create({
        data: {
          projectId: id,
          type: "LOCATION_PLAN",
          name: `${updated.name} - Location Plan`,
          metadata: { autoGenerated: true, generatedAt: new Date().toISOString() },
          creditsUsed: 0,
        },
      });
    }
  }
  return NextResponse.json({ project: updated });
}

export async function DELETE(
  _req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const user = await getSession();
  if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  const { id } = await params;
  const project = await prisma.project.findFirst({ where: { id, userId: user.id } });
  if (!project) return NextResponse.json({ error: "Not found" }, { status: 404 });
  await prisma.project.delete({ where: { id } });
  return NextResponse.json({ success: true });
}
