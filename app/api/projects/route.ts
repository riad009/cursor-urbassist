import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { getSession } from "@/lib/auth";

export async function GET() {
  const user = await getSession();
  if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  const projects = await prisma.project.findMany({
    where: { userId: user.id },
    orderBy: { updatedAt: "desc" },
    include: {
      regulatoryAnalysis: { select: { id: true, zoneType: true } },
      _count: { select: { documents: true } },
    },
  });
  return NextResponse.json({ projects });
}

export async function POST(request: NextRequest) {
  const user = await getSession();
  if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  try {
    const body = await request.json();
    const { name, description, address, municipality, parcelIds, parcelArea, coordinates, citycode, zoneType, protectedAreas, northAngle } = body;
    const project = await prisma.project.create({
      data: {
        userId: user.id,
        name: name || "New Project",
        description: description || null,
        address: address || null,
        municipality: municipality || null,
        parcelIds: Array.isArray(parcelIds) ? parcelIds.join(",") : typeof parcelIds === "string" ? parcelIds : "",
        parcelArea: parcelArea ? Number(parcelArea) : null,
        coordinates: coordinates ? JSON.stringify(coordinates) : null,
        citycode: citycode || null,
        northAngle: northAngle != null ? Number(northAngle) : null,
      },
    });

    // Auto location plan: create LOCATION_PLAN document when address and parcels are set
    const hasAddress = !!(address || project.address);
    const hasParcels = !!(Array.isArray(parcelIds) ? parcelIds.length : parcelIds) || !!coordinates;
    if (hasAddress && hasParcels) {
      const existing = await prisma.document.findFirst({
        where: { projectId: project.id, type: "LOCATION_PLAN" },
      });
      if (!existing) {
        await prisma.document.create({
          data: {
            projectId: project.id,
            type: "LOCATION_PLAN",
            name: `${project.name} - Location Plan`,
            metadata: { autoGenerated: true, generatedAt: new Date().toISOString() },
            creditsUsed: 0,
          },
        });
      }
    }

    if (zoneType) {
      await prisma.regulatoryAnalysis.create({
        data: {
          projectId: project.id,
          zoneType: String(zoneType),
          aiAnalysis: { zoneType, fromPluDetection: true },
        },
      });
    }
    if (Array.isArray(protectedAreas) && protectedAreas.length > 0) {
      await prisma.protectedArea.createMany({
        data: protectedAreas.slice(0, 20).map((a: { type?: string; name?: string; description?: string; constraints?: unknown; sourceUrl?: string }) => ({
          projectId: project.id,
          type: (a.type as string) || "INFO",
          name: (a.name as string) || "Protected area",
          description: a.description || null,
          constraints: a.constraints == null ? undefined : (a.constraints as object),
          sourceUrl: a.sourceUrl || null,
        })),
      });
    }
    return NextResponse.json({ project });
  } catch (error) {
    console.error("Create project:", error);
    return NextResponse.json({ error: "Failed to create project" }, { status: 500 });
  }
}
